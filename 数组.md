数组

数组是一种最基础的数据结构，在大部分编程语言中，数组都是从0开始编号的。

线性表与非线性表

**线性表**（Linear List），就是数据排成一条线一样的结构。每个线性表上的数据最多只有前和后两个方向，包括**数组、链表、队列、栈**等。

**数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。**

![img](https://datastructure.xiaoxiaoming.xyz/imgs/4.jpg)

非线性表，数据之间并不是简单的前后关系，有二叉树、堆、图等，如下图：

![img](https://datastructure.xiaoxiaoming.xyz/imgs/5.jpg)

数组实现随机访问的方法

数组使用了**连续的内存空间和相同类型的数据**。使得它可以“随机访问”，但同时也让数组的删除、插入操作变得非常低效，为了保证连续性，就需要做大量的搬移工作。

数组是如何实现根据下标随机访问数组呢？

以一个长度为10的int类型的数组int[] arr = new int[10]为例。

计算机会给每个内存单元分配一个地址，并通过地址来访问内存中的数据。

下图中，假设计算机给数组arr[10]，分配了一块连续的内存空间1000~1039，其中，内存块的首地址为base_address = 1000。

![img](https://datastructure.xiaoxiaoming.xyz/imgs/6.jpg)

当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：

```
arr[i]_address = base_address + i * data_type_size
```

- data_type_size表示数组中每个元素的大小。

上面的数组中存储的是int类型数据，所以data_type_size就为4个字节。

数组查找的时间复杂度

数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。

排好序的数组用二分查找，时间复杂度为O(logn)。

顺序查找，最好时间复杂度为O(1)，最差时间复杂度为O(n)，平均时间复杂度为O(n)。

数组的低效操作

插入操作

假设数组的长度为n，如果将一个数据插入到数组中的第k个位置。为了把第k个位置腾出来给新来的数据，需要将第k~n这部分的元素都顺序地往后挪一位。

如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为O(1)。但如果在数组的开头插入元素，那所有的数据都需要一次往后移动一位，所以最坏时间复杂度是O(n)。因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 （1+2+…n）/ n = O(n)。

如果数组中的数据是有序的，在某个位置插入一个新的元素时，就必须搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合，可以把新的元素直接放入数组的最后。

假设数组arr[10]中存储了如下5个元素：a、b、c、d、e。

现在需要将元素x插入到第3个位置，我们只需要将c放入到arr[5]，将arr[2]赋值为x即可：

![img](https://datastructure.xiaoxiaoming.xyz/imgs/7.jpg)

利用这种处理技巧，在特定场景下，在第k个位置插入一个元素的时间复杂度就会降为O(1)。这个处理思想在快排中也会用到。

删除操作

如果我们要删除第K个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。

如果删除数组末尾的数据，则最好的时间复杂度为O(1)，如果删除开头的数据，则最坏情况时间复杂度为O(n)，平均情况的时间复杂度也为O(n)。

实际上，在某些特定场景下，我们并不一定非得追求数组中数据的连续性。可以将多次删除操作集中在一起执行。

比如数组arr[10]中存储了8个元素：a、b、c、d、e、f、g、h。要以此删除a、b、c三个元素：

![img](https://datastructure.xiaoxiaoming.xyz/imgs/8.jpg)

为了避免d、e、f、g、h这几个数据会被搬移三次，可以先记录下已经删除的数据，每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作。

这有点像jvm标记清楚垃圾回收算法的核心思想。

警惕数组的访问越界问题

先分析一下这段c语言代码的运行结果：

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}

```

这段代码的运行结果并非是打印三行“hello world”，而是会无限打印“hello world”。

因为，数组大小为3，arr[0]，arr[1]，arr[2]，而arr[3]访问越界，在c语言中，arr[3]被定为到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址，其他高级语言一般会报角标越界异常。

那么arr[3] = 0就相当于i = 0,所以就会导致代码无限循环。

访问数组的本质就是访问一段连续内存，在c语言中只要数组通过偏移量计算得到的内存地址是可用的，那么程序就可以不会报任何错误。

c语言把数组越界检查的工作丢给程序员，但java本身就会做越界检查，比如下面这几行java代码，就会抛出java.lang.ArrayIndexOutOfBoundsException。

```java
int[] a = new int[3];
a[3] = 10;
```

容器vs数组

针对数组类型，很多语言都提供了容器类，比如java中的ArrayList、C++STL中的vector。

ArrayList最大的优势就是**可以将很多数组操作的细节封装起来**。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是**支持动态扩容**。

数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为10的数组，当第11个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。

如果使用ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为1.5倍大小。

扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建ArrayList的时候事先指定数据大小。

比如我们要从数据库中取出10000条数据放入ArrayList。我们看下面这几行代码，你会发现，相比之下，事先指定数据大小可以节省很多次内存申请和数据搬移操作。

```java
ArrayList<User> users = new ArrayList(10000);
for (int i = 0; i < 10000; ++i) {
  users.add(xxx);
}
```

有些时候用数组会更合适些：

1.Java ArrayList无法存储基本类型，比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。

2.如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组。

3.当要表示多维数组时，用数组往往会更加直观。比如Object[][] [] []array;而用容器的话则需要这样定义：

ArrayList<ArrayList> array。

总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优先于容器。

为什么数组要从0开始编号？

为什么数组要从0开始编号，而不是从1开始呢？从1开始不是更符合人类的思维习惯吗？

从数组存储的内存模型上来看，**“下标”最确切的定义应该是“偏移（offset）”**。

从0开始编号，数组arr[k]的内存寻址公式为：

```
a[k]_address = base_address + k * type_size
```

从1开始编号，数组arr[k]的内存寻址公式为：

```
a[k]_address = base_address + (k-1)*type_size
```

对比两个公式，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于cpu来说，就是多了一次减法指令。

所以为了减少一次减法操作，数组选择了从0开始编号，而不是从1开始。另外，c语言设计者用0开始计数数组下标，之后的java、javascript等高级语言都效仿了c语言，或者说，为了在一定程度上减少C语言程序员学习java的学习成本，因此继续沿用了从0开始计数的习惯。

二维数组的内存寻址公式

对于m * n的数组，arr[i] [j] (i < m, j < n)的地址为：

```
address = base_address + (i*n+j)*type_size
```

